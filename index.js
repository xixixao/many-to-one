// Generated by CoffeeScript 1.12.3
var args, chokidar, escapeStringForRegex, fileExists, fileHeader, fileHeaderRegex, fromWatched, fs, j, log, logVerbose, readFile, ready, ref, srcs, syncBack, syncForward, sysPath, target, targetPath, timestamp, toWatched, watched, watcher, yargs,
  slice = [].slice;

chokidar = require('chokidar');

escapeStringForRegex = require('escape-string-regexp');

fs = require('fs');

sysPath = require('path');

timestamp = require('time-stamp');

yargs = require('yargs');

args = yargs.usage('Usage: many-to-one [options] SOURCE ... TARGET\n\n  SOURCE is a path to a file or directory, or a glob\n  TARGET is a path to a file that will consist of the combined contents\n    of all the files specified by SOURCEs\n\nThe command will keep watching both the SOURCEs and the TARGET and sync\nthem when either change.').example('many-to-one a.js b.js c.js bundle.js', 'Sync a, b and c to bundle.').example('many-to-one -c \'#\' src/ bundle.coffee', 'Use different comment syntax for other languages.').example('many-to-one -c \'/*\' -t \'*/\' src/ all.as', 'Use different token to end file headers.').example('many-to-one src/ -i src/vendor.js all.js', 'Exclude some files from syncing.').options({
  comment: {
    alias: 'c',
    describe: 'The comment syntax used for file headers.',
    "default": '//',
    type: 'string'
  },
  ignore: {
    alias: 'i',
    describe: 'Don\'t consider these paths/globs for SOURCE files'
  },
  mangle: {
    alias: 'm',
    describe: 'Mangle the actual source file names in TARGET\'s headers.',
    type: 'boolean'
  },
  token: {
    alias: 't',
    describe: 'The end token distinguishing file headers from other comments.',
    "default": '-------------',
    type: 'string'
  },
  verbose: {
    alias: 'v',
    describe: 'Log watching status.',
    type: 'boolean'
  }
}).help().describe('help', '').demandCommand(2, 'Error: You need to supply at minimum one SOURCE and TARGET').strict().argv;

ref = args._, srcs = 2 <= ref.length ? slice.call(ref, 0, j = ref.length - 1) : (j = 0, []), target = ref[j++];

targetPath = sysPath.relative('', target);

watcher = chokidar.watch(args._, {
  cwd: '.',
  ignored: args.ignore
});

watched = {};

ready = false;

watcher.on('add', function(path) {
  watched[toWatched(path)] = true;
  logVerbose("Added `" + path + "`");
  if (path !== targetPath && ready) {
    return syncForward();
  }
});

watcher.on('change', function(path) {
  if (ready) {
    if (path === targetPath) {
      return syncBack();
    } else {
      return syncForward();
    }
  }
});

watcher.on('unlink', function(path) {
  logVerbose("Removed `" + path + "`");
  if (path !== targetPath) {
    delete watched[toWatched(path)];
  }
  return syncForward();
});

watcher.on('ready', function() {
  if ((Object.keys(watched)).length > 0) {
    syncForward();
    return ready = true;
  }
});

syncForward = function() {
  var compiled, content, oldCompiled, path, w;
  compiled = '';
  for (w in watched) {
    if (!((path = fromWatched(w)) !== targetPath)) {
      continue;
    }
    content = readFile(path);
    compiled += fileHeader(w);
    compiled += content + '\n';
  }
  compiled = compiled.slice(0, -1);
  try {
    oldCompiled = readFile(targetPath);
  } catch (error) {}
  if (oldCompiled !== compiled) {
    fs.writeFileSync(targetPath, compiled);
    return log("->");
  }
};

syncBack = function() {
  var addedNewFile, compiled, content, i, k, len, path, ref1, splitUp, stopWatching, w, write, wrote;
  compiled = readFile(targetPath);
  splitUp = compiled.split(fileHeaderRegex);
  wrote = false;
  addedNewFile = false;
  stopWatching = Object.assign({}, watched);
  ref1 = splitUp.slice(1);
  for (i = k = 0, len = ref1.length; k < len; i = k += 2) {
    w = ref1[i];
    content = splitUp[i + 2];
    if (i !== splitUp.length - 3) {
      content = content.slice(0, -1);
    }
    if (watched[w]) {
      path = fromWatched(w);
      delete stopWatching[w];
      write = (readFile(path)) !== content;
    } else {
      path = w;
      watcher.add(w);
      watched[w] = true;
      write = !fileExists(path);
      addedNewFile || (addedNewFile = !write);
      logVerbose("Started watching `" + path + "`");
    }
    if (write) {
      fs.writeFileSync(path, content);
      wrote = true;
    }
  }
  for (w in stopWatching) {
    if (!((path = fromWatched(w)) !== targetPath)) {
      continue;
    }
    watcher.unwatch(path);
    delete watched[w];
    logVerbose("Stopped watching `" + path + "`");
  }
  if (wrote || addedNewFile) {
    log("<-");
  }
  if (addedNewFile) {
    return syncForward();
  }
};

fileHeader = function(path) {
  return args.comment + " " + path + " " + args.token + "\n";
};

fileHeaderRegex = RegExp("^" + (escapeStringForRegex(args.comment)) + "\\s([^\\n]+)\\s" + (escapeStringForRegex(args.token)) + "$\\n?", "m");

readFile = function(path) {
  return fs.readFileSync(path, {
    encoding: 'utf8'
  });
};

fileExists = function(path) {
  try {
    return (fs.statSync(path)).isFile();
  } catch (error) {}
  return false;
};

toWatched = function(path) {
  if (args.mangle) {
    return new Buffer(path).toString('base64');
  } else {
    return path;
  }
};

fromWatched = function(path) {
  if (args.mangle) {
    return new Buffer(path, 'base64').toString('');
  } else {
    return path;
  }
};

logVerbose = function(message) {
  if (args.verbose) {
    return log(message);
  }
};

log = function(message) {
  return console.log((timestamp('[HH:mm:ss]')) + " " + message);
};
